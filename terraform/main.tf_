provider "aws" {
	region = var.aws_region
}

data "aws_region" "current" {}

resource "aws_vpc" "vpc1" {
	cidr_block = "172.16.0.0/16"
}

resource "aws_subnet" "subnet1" {
	vpc_id = aws_vpc.vpc1.id
	cidr_block = "172.16.10.0/24"
	availability_zone = "${data.aws_region.current.name}a"
}

resource "aws_security_group" "sec_gr1" {
	name = "${var.app_id}_sec_gr1"
	vpc_id = aws_vpc.vpc1.id

	ingress {
		from_port = 22
		to_port = 22
		protocol = "tcp"
		cidr_blocks = ["0.0.0.0/0"]
	}

	ingress {
		from_port = 6443
		to_port = 6443
		protocol = "tcp"
		cidr_blocks = ["0.0.0.0/0"]
	}

	egress {
		from_port = 0
		to_port = 0
		protocol = "-1"
		cidr_blocks = ["0.0.0.0/0"]
	}
}

resource "aws_iam_role" "ec2_role" {
	name = "${var.app_id}_ec2_role"
	path = "/${var.app}/${var.app_ver}/"

	assume_role_policy = <<EOF
{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Action": "sts:AssumeRole",
			"Principal": {
				"Service": "ec2.amazonaws.com"
			},
			"Effect": "Allow",
			"Sid": ""
		}
	]
}
EOF

}

resource "aws_iam_role_policy" "ec2_policy" {
	name = "${var.app_id}_kube_policy"
	role = aws_iam_role.ec2_role.name
	policy = data.aws_iam_policy_document.ec2_policy_doc.json
}

data "aws_iam_policy_document" "ec2_policy_doc" {
	statement {
		actions = [
			"ec2:*",
			"elasticloadbalancing:*",
			"ecr:GetAuthorizationToken",
			"ecr:BatchCheckLayerAvailability",
			"ecr:GetDownloadUrlForLayer",
			"ecr:GetRepositoryPolicy",
			"ecr:DescribeRepositories",
			"ecr:ListImages",
			"ecr:BatchGetImage",
			"route53:GetHostedZone",
			"route53:ListHostedZones",
			"route53:ListHostedZonesByName",
			"route53:ChangeResourceRecordSets",
			"route53:ListResourceRecordSets",
			"route53:GetChange"	
		]
		resources = [
			"*"
		]
	}
}

resource "aws_iam_instance_profile" "ec2_profile" {
	name = "${var.app_id}_ec2_role"
	role = aws_iam_role.ec2_role.name
}

data "template_file" "init_sh" {
	template = file("../config/init.sh")

	vars = {
		kubeadm_token = module.kubeadm-token.token
		dns_name = "${var.app_id}.${var.hosted_zone}"
		ip_address = aws_eip.eip1.public_ip
		cluster_name = var.cluster_name
		addons = join(" ", var.addons)
	}
}

data "template_cloudinit_config" "init" {
	gzip = true
	base64_encode = true

	part {
		filename = "init.sh"
		content_type = "text/x-shellscript"
		content = data.template_file.init_sh.rendered
	}
}

resource "aws_key_pair" "keypair1" {
	key_name = var.app_id
}

data "aws_ami" "ubuntu" {
	most_recent = true

	filter {
		name   = "name"
		values = ["ubuntu/images/hvm-ssd/ubuntu*"]
	}

	owners = ["099720109477"] # Canonical
}

resource "aws_instance" "ec2" {
	instance_type = "t2.micor"
	ami = data.aws_ami.ubuntu.id
	key_name = aws_key_pair.keypair1.key_name
	subnet_id = aws_subnet.subnet1.id
	associate_public_ip_address = false
	iam_instance_profile = aws_iam_instance_profile.ec2_profile.name
	user_data_base64 = data.template_cloudinit_config.init.rendered

	vpc_security_group_ids = [
		aws_security_group.sec_gr1.id,
	]

	lifecycle {
		ignore_changes = [
			ami,
			user_data,
			associate_public_ip_address,
		]
	}
}

resource "aws_eip" "eip1" {
	instance = aws_instance.ec2.id
	vpc = true
}

